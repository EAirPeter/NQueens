<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>N Queens</title>
</head>
<body>
<div id="chess-board"></div>

<script src="js/d3.min.js"></script>
<script>
    const cellSize = 40
    const margin = 21
    const queenText = "\u2655"
    const cellStatus = {
        EMPTY: 'empty',
        QUEEN: 'queen',
        QUEEN_HOVER: 'queen_hover',
        BLOCKED: 'blocked',
        BLOCKED_HOVER: 'blocked_hover'
    }

    const chessBoardDiv = d3.select("#chess-board")

    let chessBoardSvg
    let cells
    let locToCell

    function initBoard(a) {

        const boardSize = a * cellSize

        cells = []
        locToCell = {}

        for (let row = 0; row < a; row ++) {
            locToCell[row] = {}

            for (let col = 0; col < a; col ++) {
                let cell = {
                    x: row,
                    y: col,
                    fill: ((row % 2 === 0 && col % 2 === 0) || (row % 2 === 1 && col % 2 === 1)) ? "#F5F5DC" : "#D2B48C",
                    status: cellStatus.EMPTY
                }
                cells.push(cell)
                locToCell[row][col] = cell
            }
        }

        chessBoardDiv.selectAll("*").remove()

        chessBoardSvg = chessBoardDiv.append("svg")
            .attr("width", `${boardSize + margin}px`)
            .attr("height", `${boardSize + margin}px`)
            .append("g")
            .attr("transform", `translate(${margin}, ${margin})`)

        const chessBoardCells = chessBoardSvg.selectAll(".cells")
            .data(cells)
            .enter()
            .append("g")

        chessBoardCells.append("rect")
            .attr("class", "cell-rect")
            .attr("x", (d) => d.x * cellSize)
            .attr("y", (d) => d.y * cellSize)
            .attr("width", `${cellSize}px`)
            .attr("height", `${cellSize}px`)
            .attr("fill", (d) => d.fill)
            .style("cursor", "pointer")
            .on("mouseover", function (event, d) {
                if (d.status !== cellStatus.QUEEN && d.status !== cellStatus.BLOCKED) {
                    locToCell[d.x][d.y].status = cellStatus.QUEEN_HOVER

                    // same row
                    for (let row = 0; row < a; row ++) {
                        if (row !== d.x) {
                            locToCell[row][d.y].status = cellStatus.BLOCKED_HOVER
                        }
                    }

                    // same col
                    for (let col = 0; col < a; col ++) {
                        if (col !== d.y) {
                            locToCell[d.x][col].status = cellStatus.BLOCKED_HOVER
                        }
                    }

                    // same diagonal
                    for (let row = d.x - 1, col = d.y - 1; row >= 0 && col >= 0; row --, col --) {
                        locToCell[row][col].status = cellStatus.BLOCKED_HOVER
                    }
                    for (let row = d.x + 1, col = d.y + 1; row < a && col < a; row ++, col ++) {
                        locToCell[row][col].status = cellStatus.BLOCKED_HOVER
                    }
                    for (let row = d.x + 1, col = d.y - 1; row < a && col >= 0; row ++, col --) {
                        locToCell[row][col].status = cellStatus.BLOCKED_HOVER
                    }
                    for (let row = d.x - 1, col = d.y + 1; row >= 0 && col < a; row --, col ++) {
                        locToCell[row][col].status = cellStatus.BLOCKED_HOVER
                    }

                    updateBoard()
                }
            }).on("mouseout", function (event, d) {
            if (d.status === cellStatus.QUEEN_HOVER) {
                locToCell[d.x][d.y].status = cellStatus.EMPTY

                // same row
                for (let row = 0; row < a; row ++) {
                    if (row !== d.x) {
                        locToCell[row][d.y].status = cellStatus.EMPTY
                    }
                }

                // same col
                for (let col = 0; col < a; col ++) {
                    if (col !== d.y) {
                        locToCell[d.x][col].status = cellStatus.EMPTY
                    }
                }

                // same diagonal
                for (let row = d.x - 1, col = d.y - 1; row >= 0 && col >= 0; row --, col --) {
                    locToCell[row][col].status = cellStatus.EMPTY
                }
                for (let row = d.x + 1, col = d.y + 1; row < a && col < a; row ++, col ++) {
                    locToCell[row][col].status = cellStatus.EMPTY
                }
                for (let row = d.x + 1, col = d.y - 1; row < a && col >= 0; row ++, col --) {
                    locToCell[row][col].status = cellStatus.EMPTY
                }
                for (let row = d.x - 1, col = d.y + 1; row >= 0 && col < a; row --, col ++) {
                    locToCell[row][col].status = cellStatus.EMPTY
                }

                updateBoard()
            }
        })

        chessBoardCells.append("text")
            .attr("class", "cell-text")
            .attr("x", (d) => d.x * cellSize)
            .attr("y", (d) => d.y * cellSize)
            .style("font-size", `${cellSize}px`)
            .style("pointer-events", "none")
            .attr("transform", `translate(8, 32)`)

        let colLabels = []
        let rowLabels = []

        for (let row = 0; row < a; row ++) {
            rowLabels.push(row + 1)
        }

        for (let col = 0; col < a; col ++) {
            colLabels.push(numToLetter(col + 1))
        }

        chessBoardSvg.selectAll(".colLabel")
            .data(colLabels)
            .enter().append("text")
            .text((d) => d)
            .attr("y", 0)
            .attr("x", (d, i) => i * cellSize)
            .style("font-size", `${cellSize / 3}px`)
            .style("text-anchor", "middle")
            .style("opacity", 0.75)
            .attr("transform", `translate(${cellSize / 2}, -6)`)

        chessBoardSvg.selectAll(".rowLabel")
            .data(rowLabels)
            .enter().append("text")
            .text((d) => d)
            .attr("y", (d, i) => i * cellSize)
            .attr("x", 0)
            .style("font-size", `${cellSize / 3}px`)
            .style("text-anchor", "middle")
            .style("opacity", 0.75)
            .attr("transform", `translate(-15, ${cellSize / 1.5})`)
    }

    function updateBoard() {
        d3.selectAll(".cell-rect")
            .attr("fill", (d) => {
                switch (d.status) {
                    case cellStatus.BLOCKED_HOVER:
                        return d.fill === "#F5F5DC" ? "#AAAA98" : "#917C61"

                    case cellStatus.BLOCKED:
                        return d.fill === "#F5F5DC" ? "#7A7A6D" : "#685945"

                    default:
                        return d.fill
                }
            })
        d3.selectAll(".cell-text")
            .text((d) => {
                switch (d.status) {
                    case cellStatus.QUEEN:
                    case cellStatus.QUEEN_HOVER:
                        return queenText

                    default:
                        return ""
                }
            })
    }

    function numToLetter(num) {
        const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        let result = ""

        while (num > 0) {
            let charIndex = num % alphabet.length
            num = Math.floor(num / alphabet.length)

            if(charIndex - 1 === -1){
                charIndex = alphabet.length
                num --;
            }

            result = alphabet.charAt(charIndex-1) + result;
        }

        return result
    }

    initBoard(10)
</script>
</body>
</html>